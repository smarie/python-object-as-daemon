{
    "docs": [
        {
            "location": "/",
            "text": "python-object-as-daemon (pyoad)\n\u00b6\n\n\n \n \n \n\n\nTiny utility to spawn an object in a separate process, possibly using another python executable/environment. The object may be accessed from the main process through a proxy with similar behaviour. This project relies on the default multiprocessing module, therefore:\n\n\n\n\nthe child environment does not require any particular package to be present (not even this package). It makes it quite convenient to launch tasks/tests on specific environments.\n\n\ncommunication between processes is done using multiprocessing Pipes\n\n\n\n\nInstalling\n\u00b6\n\n\n> pip install pyoad\n\n\n\n\n\nBasic Usage\n\u00b6\n\n\nCreating\n\u00b6\n\n\nLet us create a string instance and send it into a daemon:\n\n\nfrom\n \npyoad\n \nimport\n \nObjectDaemonProxy\n\n\ndaemon_str\n \n=\n \nObjectDaemonProxy\n(\n'hello, world!'\n)\n\n\n\n\n\n\nThe outcome is :\n\n\n[\n15756\n]\n Object daemon started in : C:\n\\A\nnaconda3\n\\e\nnvs\n\\t\nools\n\\p\nython.exe\n\n\n\n\n\nNote that the spawned process id is printed, for reference (here, \n[15756]\n). You can check in your OS process manager that there is a new python process running under this pid.\n\n\nCalling\n\u00b6\n\n\nYou may now interact with the proxy as if the object were still local:\n\n\nprint\n(\ndaemon_str\n)\n\n\nprint\n(\ndaemon_str\n[\n0\n:\n5\n])\n\n\n\n\n\n\nhello, world!\nhello\n\n\n\n\n\nDisposing\n\u00b6\n\n\nIf you dispose of the object by releasing any reference to it, the daemon process will automatically terminate the next time the python garbage collector runs:\n\n\ndaemon_str\n \n=\n \nNone\n\n\nimport\n \ngc\n\n\ngc\n.\ncollect\n()\n  \n# explicitly ask for garbage collection right now\n\n\n\n\n\n\nDisplays:\n\n\n[\n15756\n]\n Object daemon  was asked to \nexit\n - closing communication connection\n\n[\n15756\n]\n Object daemon  terminating\n\n\n\n\n\nAdvanced\n\u00b6\n\n\nDaemon-side instantiation\n\u00b6\n\n\nIn most cases you'll probably want the daemon to instantiate the object, not the main process. For this purpose the \nInstanceDefinition\n class may be used to describe what you want to instantiate:\n\n\nfrom\n \npyoad\n \nimport\n \nObjectDaemonProxy\n,\n \nInstanceDefinition\n\n\ndefinition\n \n=\n \nInstanceDefinition\n(\n'io'\n,\n \n'StringIO'\n,\n \n'hello, world!'\n)\n\n\ndaemon_strio\n \n=\n \nObjectDaemonProxy\n(\ndefinition\n)\n\n\nprint\n(\ndaemon_strio\n.\ngetvalue\n())\n\n\n\n\n\n\nNote that the module name may be set to \nbuiltins\n for built-ins:\n\n\nfrom\n \npyoad\n \nimport\n \nObjectDaemonProxy\n,\n \nInstanceDefinition\n\n\ndaemon_str_int\n \n=\n \nObjectDaemonProxy\n(\nInstanceDefinition\n(\n'builtins'\n,\n \n'str'\n,\n \n1\n))\n\n\nprint\n(\ndaemon_str_int\n)\n\n\n\n\n\n\nNote: if the module is set to \nNone\n, the class name is looked for in \nglobals()\n\n\nChoice of python executable/environment\n\u00b6\n\n\nYou may wish to run the daemon in a given python environment, typically different from the one your main process runs into:\n\n\ndaemon\n \n=\n \nObjectDaemonProxy\n(\n...\n,\n \npython_exe\n=\n'<path_to_python.exe>'\n)\n\n\n\n\n\n\nLog levels\n\u00b6\n\n\nThis is how you change the module default logging level : \n\n\nimport\n \nlogging\n\n\nlogging\n.\ngetLogger\n(\n'pyoad'\n)\n.\nsetLevel\n(\nlogging\n.\nDEBUG\n)\n\n\n\n\n\n\nOtherwise you may also wish to provide your own logger:\n\n\ndaemon\n \n=\n \nObjectDaemonProxy\n(\n...\n,\n \nlogger\n \n=\n \nMyLogger\n())\n\n\n\n\n\n\nSee Also\n\u00b6\n\n\nThere are many libraries out there that provide much more functionality to distribute objects. The difference with \npyoad\n is that they are bigger and typically require something to be installed on the server side. However the gain in features is often incredibly high (distribution over networks, object registries, compliance with other languages...). Check them out ! \n\n\n\n\nPyRo\n\n\nRPyC\n\n\n\n\nSome smaller projects from the community:\n\n\n\n\ncluster-func\n\n\ndproxify\n\n\n\n\nDo you like this library ? You might also like \nthese\n \n\n\nWant to contribute ?\n\u00b6\n\n\nDetails on the github page: \nhttps://github.com/smarie/python-object-as-daemon",
            "title": "Home"
        },
        {
            "location": "/#python-object-as-daemon-pyoad",
            "text": "Tiny utility to spawn an object in a separate process, possibly using another python executable/environment. The object may be accessed from the main process through a proxy with similar behaviour. This project relies on the default multiprocessing module, therefore:   the child environment does not require any particular package to be present (not even this package). It makes it quite convenient to launch tasks/tests on specific environments.  communication between processes is done using multiprocessing Pipes",
            "title": "python-object-as-daemon (pyoad)"
        },
        {
            "location": "/#installing",
            "text": "> pip install pyoad",
            "title": "Installing"
        },
        {
            "location": "/#basic-usage",
            "text": "",
            "title": "Basic Usage"
        },
        {
            "location": "/#creating",
            "text": "Let us create a string instance and send it into a daemon:  from   pyoad   import   ObjectDaemonProxy  daemon_str   =   ObjectDaemonProxy ( 'hello, world!' )   The outcome is :  [ 15756 ]  Object daemon started in : C: \\A naconda3 \\e nvs \\t ools \\p ython.exe  Note that the spawned process id is printed, for reference (here,  [15756] ). You can check in your OS process manager that there is a new python process running under this pid.",
            "title": "Creating"
        },
        {
            "location": "/#calling",
            "text": "You may now interact with the proxy as if the object were still local:  print ( daemon_str )  print ( daemon_str [ 0 : 5 ])   hello, world!\nhello",
            "title": "Calling"
        },
        {
            "location": "/#disposing",
            "text": "If you dispose of the object by releasing any reference to it, the daemon process will automatically terminate the next time the python garbage collector runs:  daemon_str   =   None  import   gc  gc . collect ()    # explicitly ask for garbage collection right now   Displays:  [ 15756 ]  Object daemon  was asked to  exit  - closing communication connection [ 15756 ]  Object daemon  terminating",
            "title": "Disposing"
        },
        {
            "location": "/#advanced",
            "text": "",
            "title": "Advanced"
        },
        {
            "location": "/#daemon-side-instantiation",
            "text": "In most cases you'll probably want the daemon to instantiate the object, not the main process. For this purpose the  InstanceDefinition  class may be used to describe what you want to instantiate:  from   pyoad   import   ObjectDaemonProxy ,   InstanceDefinition  definition   =   InstanceDefinition ( 'io' ,   'StringIO' ,   'hello, world!' )  daemon_strio   =   ObjectDaemonProxy ( definition )  print ( daemon_strio . getvalue ())   Note that the module name may be set to  builtins  for built-ins:  from   pyoad   import   ObjectDaemonProxy ,   InstanceDefinition  daemon_str_int   =   ObjectDaemonProxy ( InstanceDefinition ( 'builtins' ,   'str' ,   1 ))  print ( daemon_str_int )   Note: if the module is set to  None , the class name is looked for in  globals()",
            "title": "Daemon-side instantiation"
        },
        {
            "location": "/#choice-of-python-executableenvironment",
            "text": "You may wish to run the daemon in a given python environment, typically different from the one your main process runs into:  daemon   =   ObjectDaemonProxy ( ... ,   python_exe = '<path_to_python.exe>' )",
            "title": "Choice of python executable/environment"
        },
        {
            "location": "/#log-levels",
            "text": "This is how you change the module default logging level :   import   logging  logging . getLogger ( 'pyoad' ) . setLevel ( logging . DEBUG )   Otherwise you may also wish to provide your own logger:  daemon   =   ObjectDaemonProxy ( ... ,   logger   =   MyLogger ())",
            "title": "Log levels"
        },
        {
            "location": "/#see-also",
            "text": "There are many libraries out there that provide much more functionality to distribute objects. The difference with  pyoad  is that they are bigger and typically require something to be installed on the server side. However the gain in features is often incredibly high (distribution over networks, object registries, compliance with other languages...). Check them out !    PyRo  RPyC   Some smaller projects from the community:   cluster-func  dproxify   Do you like this library ? You might also like  these",
            "title": "See Also"
        },
        {
            "location": "/#want-to-contribute",
            "text": "Details on the github page:  https://github.com/smarie/python-object-as-daemon",
            "title": "Want to contribute ?"
        }
    ]
}