{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"spawny \u00b6 Spawn python code in a separate python interpreter and communicate with it easily. New: entire scripts can now be run remotely, check it out ! Do you want to run python code in a separate process, in a separate python interpreter, while still being able to communicate with it easily ? spawny was made for this. It relies on the built-in multiprocessing module, but provides a higher-level API so that it is extremely easy for a non-expert to get started. The child python environment does not require any particular package to be present (not even the spawny package). The subprocess may be accessed from the main process through a \"proxy\" python object . Simply call that object, this will use a multiprocessing Pipe behind the scenes. Installing \u00b6 > pip install spawny Usage \u00b6 Executing a script \u00b6 Let's write some python code and put it in a variable: script = \"\"\" from collections import OrderedDict odct = OrderedDict() odct['a'] = 1 foo = \"hello world\" def say_hello(who): return \"hello %s \" % who print(say_hello(\"process\")) \"\"\" To execute this script in a subprocess, all you have to do is call run_script : from spawny import run_script # execute the script in another process daemon_module = run_script ( script ) It yields: [ DaemonProxy ] spawning child process... [ 11100 ] Daemon started using python interpreter: <path>/python.exe hello, process! [ DaemonProxy ] spawning child process... DONE. PID = 11100 Now your script is running in a subprocess, with process id 11100 as indicated in the printed message. You can check in your OS process manager that there is a new python process running under this pid. What happened behind the scenes is that the subprocess spawned loaded your script in a dynamically created module. You can see that module was ent with the hello, process! print that comes from the end of the script. The daemon_module variable now contains a proxy able to communicate with it through inter-process communication ( multiprocessing.Pipe ). So you can access all the variables created in your script, and each variable will contain a proxy to the respective object. You can interact with each variable as it the objects were here: # interact with it: print ( daemon_module . odct ) assert daemon_module . foo == \"hello world\" assert daemon_module . say_hello ( \"earthling\" ) == \"hello earthling\" Note that the results of interacting with these variables are then received as plain python object, not as proxy. Only the main variable ( daemon_module ) and the first-level variables ( daemon_module.odct , etc.) are proxies. You can check it with: print ( type ( daemon_module . foo )) # ObjectProxy print ( type ( daemon_module . say_hello ( \"earthling\" ))) # str Disposing \u00b6 If you dispose of the object by releasing any reference to it, the daemon process will automatically terminate the next time the python garbage collector runs: daemon_module = None import gc gc . collect () # explicitly ask for garbage collection right now Displays: [ 11100 ] Object daemon was asked to exit - closing communication connection [ 11100 ] Object daemon terminating [ DaemonProxy< 11100 > ] Terminated successfully Note that this only happens if there is no remaining object proxy in any of your variable. You can reach the same result explicitly, by calling the .terminate_daemon() method on any of your object proxies (the main one or the second-level ones): daemon_module . terminate_daemon () Executing a module \u00b6 Simply use run_module instead of run_script . You can either provide a module name if the module is already imported, or a name and a path if the module file is not imported in the caller process. Executing a single object \u00b6 For this purpose the InstanceDefinition class may be used to describe what you want to instantiate: from spawny import InstanceDefinition , run_object definition = InstanceDefinition ( 'io' , 'StringIO' , 'hello, world!' ) daemon_strio = run_object ( definition ) print ( daemon_strio . getvalue ()) Note that the module name may be set to builtins for built-ins: from spawny import run_object , InstanceDefinition daemon_str_int = run_object ( InstanceDefinition ( 'builtins' , 'str' , 1 )) print ( daemon_str_int ) Note: if the module is set to None , the class name is looked for in globals() Advanced \u00b6 Choice of python executable/environment \u00b6 You may wish to run the daemon in a given python environment, typically different from the one your main process runs into: daemon = run_xxx ( ... , python_exe = '<path_to_python.exe>' ) Log levels \u00b6 This is how you change the module default logging level : import logging logging . getLogger ( spawny ) . setLevel ( logging . DEBUG ) Otherwise you may also wish to provide your own logger: from logging import getLogger , FileHandler , INFO my_logger = getLogger ( 'mine' ) my_logger . addHandler ( FileHandler ( 'hello.log' )) my_logger . setLevel ( INFO ) daemon = run_xxx ( ... , logger = my_logger ) See Also \u00b6 The multiprocessing built-in python module. There are many libraries out there that provide much more functionality to distribute objects. The difference with spawny is that they are bigger and typically require something to be installed on the server side. However the gain in features is often incredibly high (distribution over networks, object registries, compliance with other languages...). Check them out ! PyRo RPyC Some smaller projects from the community: cluster-func dproxify Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-spawny","title":"Home"},{"location":"#spawny","text":"Spawn python code in a separate python interpreter and communicate with it easily. New: entire scripts can now be run remotely, check it out ! Do you want to run python code in a separate process, in a separate python interpreter, while still being able to communicate with it easily ? spawny was made for this. It relies on the built-in multiprocessing module, but provides a higher-level API so that it is extremely easy for a non-expert to get started. The child python environment does not require any particular package to be present (not even the spawny package). The subprocess may be accessed from the main process through a \"proxy\" python object . Simply call that object, this will use a multiprocessing Pipe behind the scenes.","title":"spawny"},{"location":"#installing","text":"> pip install spawny","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#executing-a-script","text":"Let's write some python code and put it in a variable: script = \"\"\" from collections import OrderedDict odct = OrderedDict() odct['a'] = 1 foo = \"hello world\" def say_hello(who): return \"hello %s \" % who print(say_hello(\"process\")) \"\"\" To execute this script in a subprocess, all you have to do is call run_script : from spawny import run_script # execute the script in another process daemon_module = run_script ( script ) It yields: [ DaemonProxy ] spawning child process... [ 11100 ] Daemon started using python interpreter: <path>/python.exe hello, process! [ DaemonProxy ] spawning child process... DONE. PID = 11100 Now your script is running in a subprocess, with process id 11100 as indicated in the printed message. You can check in your OS process manager that there is a new python process running under this pid. What happened behind the scenes is that the subprocess spawned loaded your script in a dynamically created module. You can see that module was ent with the hello, process! print that comes from the end of the script. The daemon_module variable now contains a proxy able to communicate with it through inter-process communication ( multiprocessing.Pipe ). So you can access all the variables created in your script, and each variable will contain a proxy to the respective object. You can interact with each variable as it the objects were here: # interact with it: print ( daemon_module . odct ) assert daemon_module . foo == \"hello world\" assert daemon_module . say_hello ( \"earthling\" ) == \"hello earthling\" Note that the results of interacting with these variables are then received as plain python object, not as proxy. Only the main variable ( daemon_module ) and the first-level variables ( daemon_module.odct , etc.) are proxies. You can check it with: print ( type ( daemon_module . foo )) # ObjectProxy print ( type ( daemon_module . say_hello ( \"earthling\" ))) # str","title":"Executing a script"},{"location":"#disposing","text":"If you dispose of the object by releasing any reference to it, the daemon process will automatically terminate the next time the python garbage collector runs: daemon_module = None import gc gc . collect () # explicitly ask for garbage collection right now Displays: [ 11100 ] Object daemon was asked to exit - closing communication connection [ 11100 ] Object daemon terminating [ DaemonProxy< 11100 > ] Terminated successfully Note that this only happens if there is no remaining object proxy in any of your variable. You can reach the same result explicitly, by calling the .terminate_daemon() method on any of your object proxies (the main one or the second-level ones): daemon_module . terminate_daemon ()","title":"Disposing"},{"location":"#executing-a-module","text":"Simply use run_module instead of run_script . You can either provide a module name if the module is already imported, or a name and a path if the module file is not imported in the caller process.","title":"Executing a module"},{"location":"#executing-a-single-object","text":"For this purpose the InstanceDefinition class may be used to describe what you want to instantiate: from spawny import InstanceDefinition , run_object definition = InstanceDefinition ( 'io' , 'StringIO' , 'hello, world!' ) daemon_strio = run_object ( definition ) print ( daemon_strio . getvalue ()) Note that the module name may be set to builtins for built-ins: from spawny import run_object , InstanceDefinition daemon_str_int = run_object ( InstanceDefinition ( 'builtins' , 'str' , 1 )) print ( daemon_str_int ) Note: if the module is set to None , the class name is looked for in globals()","title":"Executing a single object"},{"location":"#advanced","text":"","title":"Advanced"},{"location":"#choice-of-python-executableenvironment","text":"You may wish to run the daemon in a given python environment, typically different from the one your main process runs into: daemon = run_xxx ( ... , python_exe = '<path_to_python.exe>' )","title":"Choice of python executable/environment"},{"location":"#log-levels","text":"This is how you change the module default logging level : import logging logging . getLogger ( spawny ) . setLevel ( logging . DEBUG ) Otherwise you may also wish to provide your own logger: from logging import getLogger , FileHandler , INFO my_logger = getLogger ( 'mine' ) my_logger . addHandler ( FileHandler ( 'hello.log' )) my_logger . setLevel ( INFO ) daemon = run_xxx ( ... , logger = my_logger )","title":"Log levels"},{"location":"#see-also","text":"The multiprocessing built-in python module. There are many libraries out there that provide much more functionality to distribute objects. The difference with spawny is that they are bigger and typically require something to be installed on the server side. However the gain in features is often incredibly high (distribution over networks, object registries, compliance with other languages...). Check them out ! PyRo RPyC Some smaller projects from the community: cluster-func dproxify Do you like this library ? You might also like my other python libraries","title":"See Also"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-spawny","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 2.1.2 - Added __version__ attribute \u00b6 Added __version__ attribute at package level. 2.1.1 - Fixed issue with python 2 \u00b6 Fixed #15 . 2.1.0 - Better protection against exceptions in the daemon \u00b6 Now exceptions happening on the daemon side always result in a corresponding message being sent to the client, even if the exception itself is not picklable. Fixes #14 . 2.0.2 - bugfix \u00b6 Fixed error with typing module on some 3.7 distributions. Fixed #13 . 2.0.1 - Support for scripts, new name: spawny , support for python 2. \u00b6 General: The package is now named spawny . Let's hope that it will be a more intuitive name for users :) Added support for python 2. Fixed #4 API: You can now execute an entire script or a module in the daemon, thanks to new ScriptDefinition and ModuleDefinition . A new Definition super type was created that is the parent of all definitions. ObjectDaemonProxy was renamed DaemonProxy because it now represents the proxy for the entire daemon, whatever it is, while new class ObjectProxy represents the proxy for a given object. Several ObjectProxy rely on the same DaemonProxy to communicate with the other process. Fixes #2 and #7 . New high-level methods: run_script , run_module , run_object . These make the doc much easier to read and the package more intuitive to use. Other features: Now catching exceptions happening at initialization time, and reporting them in the caller. Fixed #5 . Fixed bug with python 2 ints not implementing rich comparison. Fixed #12 1.0.2 - Better travis integration \u00b6 added test reports generation added automatic PyPI deployment 1.0.1 - Bugfix for linux and Travis integration \u00b6 removed reference to PipeConnection in PEP484 annotation. fixes #1 (bug on Linux environments) integrated in travis: tests, code coverage, doc generation 1.0.0 - First public working version \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#212-added-__version__-attribute","text":"Added __version__ attribute at package level.","title":"2.1.2 - Added __version__ attribute"},{"location":"changelog/#211-fixed-issue-with-python-2","text":"Fixed #15 .","title":"2.1.1 - Fixed issue with python 2"},{"location":"changelog/#210-better-protection-against-exceptions-in-the-daemon","text":"Now exceptions happening on the daemon side always result in a corresponding message being sent to the client, even if the exception itself is not picklable. Fixes #14 .","title":"2.1.0 - Better protection against exceptions in the daemon"},{"location":"changelog/#202-bugfix","text":"Fixed error with typing module on some 3.7 distributions. Fixed #13 .","title":"2.0.2 - bugfix"},{"location":"changelog/#201-support-for-scripts-new-name-spawny-support-for-python-2","text":"General: The package is now named spawny . Let's hope that it will be a more intuitive name for users :) Added support for python 2. Fixed #4 API: You can now execute an entire script or a module in the daemon, thanks to new ScriptDefinition and ModuleDefinition . A new Definition super type was created that is the parent of all definitions. ObjectDaemonProxy was renamed DaemonProxy because it now represents the proxy for the entire daemon, whatever it is, while new class ObjectProxy represents the proxy for a given object. Several ObjectProxy rely on the same DaemonProxy to communicate with the other process. Fixes #2 and #7 . New high-level methods: run_script , run_module , run_object . These make the doc much easier to read and the package more intuitive to use. Other features: Now catching exceptions happening at initialization time, and reporting them in the caller. Fixed #5 . Fixed bug with python 2 ints not implementing rich comparison. Fixed #12","title":"2.0.1 - Support for scripts, new name: spawny, support for python 2."},{"location":"changelog/#102-better-travis-integration","text":"added test reports generation added automatic PyPI deployment","title":"1.0.2 - Better travis integration"},{"location":"changelog/#101-bugfix-for-linux-and-travis-integration","text":"removed reference to PipeConnection in PEP484 annotation. fixes #1 (bug on Linux environments) integrated in travis: tests, code coverage, doc generation","title":"1.0.1 - Bugfix for linux and Travis integration"},{"location":"changelog/#100-first-public-working-version","text":"","title":"1.0.0 - First public working version"},{"location":"long_description/","text":"python-getversion \u00b6 Spawn python code in a separate python interpreter and communicate with it easily. The documentation for users is available here: https://smarie.github.io/python-spawny/ A readme for developers is available here: https://github.com/smarie/python-spawny","title":"python-getversion"},{"location":"long_description/#python-getversion","text":"Spawn python code in a separate python interpreter and communicate with it easily. The documentation for users is available here: https://smarie.github.io/python-spawny/ A readme for developers is available here: https://github.com/smarie/python-spawny","title":"python-getversion"}]}